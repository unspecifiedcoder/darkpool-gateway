export const ClaimCircuit = {
  noir_version: "1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d",
  hash: "440680323709621455",
  abi: {
    parameters: [
      { name: "claim_value", type: { kind: "field" }, visibility: "public" },
      { name: "_note_nonce", type: { kind: "field" }, visibility: "public" },
      {
        name: "receiver_secretHash",
        type: { kind: "field" },
        visibility: "public",
      },
      { name: "merkle_root", type: { kind: "field" }, visibility: "public" },
      {
        name: "existingNullifier",
        type: { kind: "field" },
        visibility: "public",
      },
      { name: "label", type: { kind: "field" }, visibility: "private" },
      { name: "leaf_index", type: { kind: "field" }, visibility: "private" },
      {
        name: "receiver_secret",
        type: { kind: "field" },
        visibility: "private",
      },
      { name: "newNullifier", type: { kind: "field" }, visibility: "private" },
      { name: "newSecret", type: { kind: "field" }, visibility: "private" },
      { name: "existingValue", type: { kind: "field" }, visibility: "private" },
      {
        name: "existingSecret",
        type: { kind: "field" },
        visibility: "private",
      },
      {
        name: "siblings",
        type: { kind: "array", length: 32, type: { kind: "field" } },
        visibility: "private",
      },
    ],
    return_type: { abi_type: { kind: "field" }, visibility: "public" },
    error_types: {},
  },
  bytecode:
    "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",
  debug_symbols:
    "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",
  file_map: {
    "18": {
      source:
        'pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            "BIT_SIZE must be less than modulus_num_bits",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, "radix must be greater than 1");\n            static_assert(radix <= 256, "radix must be less than or equal to 256");\n            static_assert(radix & (radix - 1) == 0, "radix must be a power of 2");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, "radix must be greater than 1");\n            static_assert(radix <= 256, "radix must be less than or equal to 256");\n            static_assert(radix & (radix - 1) == 0, "radix must be a power of 2");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = "radix must be greater than 1")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f"radix must be greater than 1");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, "unexpected result");\n    //    }\n    //}\n\n    #[test(should_fail_with = "radix must be a power of 2")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f"radix must be a power of 2");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, "unexpected result");\n        }\n    }\n\n    #[test(should_fail_with = "radix must be less than or equal to 256")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f"radix must be less than or equal to 256")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, "unexpected result");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n',
      path: "std/field/mod.nr",
    },
    "50": {
      source:
        "global MAX_TREE_DEPTH: u32 = 32;\n\nuse helpers::{commitment::commitment_hasher, LeanIMTInclusionProof::lean_imt_inclusion_proof};\nuse poseidon;\n\n// Claims funds from one of existing notes, note_nonce is used to prevent replay attacks\n// if existing nullifiers and secrets are null then we can assume user is new to system and we can create a new commitment.\n// if existing nullifiers and secrets are not null then we topup/update balance of user accordingly\nfn main(\n    // Public inputs\n    claim_value: pub Field,\n    _note_nonce: pub Field,\n    receiver_secretHash: pub Field,\n    // could be null\n    merkle_root: pub Field,\n    existingNullifier: pub Field,\n    // Private inputs\n    label: Field,\n    leaf_index: Field,\n    receiver_secret: Field,\n    newNullifier: Field,\n    newSecret: Field,\n    // could be null\n    existingValue: Field,\n    existingSecret: Field,\n    siblings: [Field; MAX_TREE_DEPTH],\n) -> pub Field {\n    assert(receiver_secretHash == poseidon::poseidon2::Poseidon2::hash([receiver_secret], 1));\n\n    let mut final_balance = claim_value;\n    if (existingNullifier != 0) {\n        let existingCommitment = commitment_hasher(\n            existingNullifier,\n            existingValue,\n            label,\n            existingSecret,\n        );\n        let computed_merkle_root = lean_imt_inclusion_proof(\n            existingCommitment,\n            leaf_index,\n            siblings,\n        );\n\n        assert_eq(computed_merkle_root, merkle_root);\n\n        final_balance += existingValue;\n    }\n\n    let newCommitment = commitment_hasher(newNullifier, final_balance, label, newSecret);\n\n    newCommitment\n}\n\n#[test]\nfn test_main() {\n    let claim_value = 500000000000000000;\n    let note_nonce = 12345;\n    let receiver_secretHash = 0x29d532dfd7450897f3a457becb789ab8aaa85aa057c39805a609471519b68a16;\n    let merkle_root = 0x0de6f3accefd10fa9b4b051932b99164ed2a6c01b6e9b87c8780210106181625;\n    let leaf_index = 5;\n    let existingNullifier = 5;\n    let label = 0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97;\n    let receiver_secret = 66666;\n    let newNullifier = 601;\n    let newSecret = 602;\n    let existingValue = 1000000000000000000;\n    let existingSecret = 10;\n    let siblings: [Field; MAX_TREE_DEPTH] = [\n        0x01a266bea8075ed4764fca5aa9b814960c483ccd158250bd39be32cf7601f85e,\n        0x08d3fc1b356a70549258380c0a14fa88e867fae608de826c52e2dd4ac6925991,\n        0x10f1429fb1ead8599a0983333927e3808984c2adbf461680fba56df177bd716b,\n        0x13742416d4952f1d797784b0d35666a4a7a571b15216e4666a50413f1359c379,\n        0x157c16f3a85aab8894515d346701cf48819a872da5da00c624b70da5d1d52799,\n        0x2ba1a5a86b4ab6cb6fa65b4a9a467aa357215c3579a5440fb31f535578585d77,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n    ];\n\n    let main_result = main(\n        claim_value,\n        note_nonce,\n        receiver_secretHash,\n        merkle_root,\n        existingNullifier,\n        label,\n        leaf_index,\n        receiver_secret,\n        newNullifier,\n        newSecret,\n        existingValue,\n        existingSecret,\n        siblings,\n    );\n\n    assert(main_result == 0x29159b8cb187abd88dbc88851d73b10f8e898dd814d164b3da914959a018bb96);\n}\n",
      path: "/mnt/c/codebases/xythum/dark-dex-research/dark-dex-v0/circuits/claim/src/main.nr",
    },
    "51": {
      source:
        "/**\n * @title LeanIMTInclusionProof function (Noir equivalent)\n * @dev Function for verifying inclusion proofs in a Lean Incremental Merkle Tree using BLAKE3 hashes.\n*/\npub fn lean_imt_inclusion_proof<let MAX_DEPTH: u32>(\n    leaf: Field,\n    leaf_index: Field, // The index of the leaf.\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    let path_bits_bool: [u1; MAX_DEPTH] = leaf_index.to_le_bits();\n\n    // `nodes` array to store computed node values at each level\n    // Size is MAX_DEPTH + 1 to store the initial leaf and results of MAX_DEPTH hashing/propagation steps.\n    let mut nodes: [Field; MAX_DEPTH + 1] = [0 as Field; MAX_DEPTH + 1];\n\n    // Initialize with the leaf value\n    nodes[0] = leaf;\n\n    // For each level up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        let current_node = nodes[i];\n        let sibling_node = siblings[i];\n\n        // `path_bits_field[i]` determines if `current_node` is a left (0) or right (1) child.\n        let path_direction_bit = path_bits_bool[i]; // 0 if current_node is left, 1 if current_node is right\n\n        // LeanIMT feature: if sibling_node is empty (0), propagate current_node.\n        // Otherwise, use the hash.\n        // `is_sibling_empty_selector` will be 1 if sibling_node is 0, and 0 otherwise.\n        let is_sibling_empty_selector = if sibling_node == 0 {\n            1 as Field\n        } else {\n            0 as Field\n        };\n\n        if is_sibling_empty_selector == 1 {\n            nodes[i + 1] = current_node;\n        } else {\n            let mut left_input: Field = 0 as Field;\n            let mut right_input: Field = 0 as Field;\n            if path_direction_bit == 0 {\n                left_input = current_node;\n                right_input = sibling_node;\n            } else {\n                left_input = sibling_node;\n                right_input = current_node;\n            }\n\n            // Hash the correctly ordered pair using BLAKE3\n            let hashed_pair = poseidon::poseidon2::Poseidon2::hash([left_input, right_input], 2);\n            nodes[i + 1] = hashed_pair;\n        }\n    }\n\n    // Output the final computed root\n    nodes[MAX_DEPTH]\n}\n\n#[test]\npub fn test_lean_imt_inclusion_proof() {\n    let leaf: Field = (4 as u8).into();\n    let leaf_index: Field = (3 as u8).into();\n    let siblings: [Field; 8] = [\n        3,\n        0x038682aa1cb5ae4e0a3f13da432a95c77c5c111f6f030faf9cad641ce1ed7383,\n        0x232400b3cca0da78d26295f345d21e9bf8949238bee02b285140ebf183119982,\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    let root = lean_imt_inclusion_proof(leaf, leaf_index, siblings);\n    assert(root == 0x05d7e5aaddb74c086c24617065e8c97dea94b86fdae0eab7b498249e0dfee2a8);\n}\n",
      path: "/mnt/c/codebases/xythum/dark-dex-research/dark-dex-v0/circuits/helpers/src/LeanIMTInclusionProof.nr",
    },
    "53": {
      source:
        "use poseidon;\n\n/**\n * @title CommitmentHasher function\n * @dev Function for computing commitment hashes, precommitments and nullifier hashes\n */\npub fn commitment_hasher(\n    nullifier: Field, // Nullifier of commitment\n    value: Field, // Value of commitment\n    label: Field,\n    secret: Field, // Secret of commitment\n) -> (Field) {\n    // println(nullifier);\n\n    let precommitment = poseidon::poseidon2::Poseidon2::hash([nullifier, secret], 2);\n    let commitment = poseidon::poseidon2::Poseidon2::hash([value, label, precommitment], 3);\n\n    // println([precommitment, commitment]);\n    (commitment)\n}\n\n#[test]\npub fn test_commitment_hasher() {\n    let nullifier: Field = (1 as u8).into();\n    let secret: Field = (2 as u8).into();\n    let value: Field = (1000000000000000000 as u64).into();\n    let label: Field = (0x4838b106fce9647bdf1e7877bf73ce8b0bad5f97).into();\n    let _commitment = commitment_hasher(nullifier, value, label, secret);\n    assert_eq(_commitment, 0x16e83a643e94248403eb0078a4b6996acf63857e47be823fdba2f0274aa66447)\n}\n",
      path: "/mnt/c/codebases/xythum/dark-dex-research/dark-dex-v0/circuits/helpers/src/commitment.nr",
    },
    "61": {
      source:
        "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      path: "/home/dimeb/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
    },
  },
  names: ["main"],
  brillig_names: ["directive_invert", "directive_to_radix"],
};
