export const WithdrawTransferCircuit = {
  noir_version: "1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d",
  hash: "4521525531046186833",
  abi: {
    parameters: [
      { name: "withdraw_value", type: { kind: "field" }, visibility: "public" },
      { name: "merkle_root", type: { kind: "field" }, visibility: "public" },
      {
        name: "existingNullifier",
        type: { kind: "field" },
        visibility: "public",
      },
      { name: "leaf_index", type: { kind: "field" }, visibility: "private" },
      { name: "label", type: { kind: "field" }, visibility: "private" },
      { name: "existingValue", type: { kind: "field" }, visibility: "private" },
      {
        name: "existingSecret",
        type: { kind: "field" },
        visibility: "private",
      },
      { name: "newNullifier", type: { kind: "field" }, visibility: "private" },
      { name: "newSecret", type: { kind: "field" }, visibility: "private" },
      {
        name: "siblings",
        type: { kind: "array", length: 32, type: { kind: "field" } },
        visibility: "private",
      },
    ],
    return_type: { abi_type: { kind: "field" }, visibility: "public" },
    error_types: {},
  },
  bytecode:
    "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",
  debug_symbols:
    "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",
  file_map: {
    "18": {
      source:
        'pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            "BIT_SIZE must be less than modulus_num_bits",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, "radix must be greater than 1");\n            static_assert(radix <= 256, "radix must be less than or equal to 256");\n            static_assert(radix & (radix - 1) == 0, "radix must be a power of 2");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, "radix must be greater than 1");\n            static_assert(radix <= 256, "radix must be less than or equal to 256");\n            static_assert(radix & (radix - 1) == 0, "radix must be a power of 2");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = "radix must be greater than 1")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f"radix must be greater than 1");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, "unexpected result");\n    //    }\n    //}\n\n    #[test(should_fail_with = "radix must be a power of 2")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f"radix must be a power of 2");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, "unexpected result");\n        }\n    }\n\n    #[test(should_fail_with = "radix must be less than or equal to 256")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f"radix must be less than or equal to 256")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, "unexpected result");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n',
      path: "std/field/mod.nr",
    },
    "51": {
      source:
        "/**\n * @title LeanIMTInclusionProof function (Noir equivalent)\n * @dev Function for verifying inclusion proofs in a Lean Incremental Merkle Tree using BLAKE3 hashes.\n*/\npub fn lean_imt_inclusion_proof<let MAX_DEPTH: u32>(\n    leaf: Field,\n    leaf_index: Field, // The index of the leaf.\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    let path_bits_bool: [u1; MAX_DEPTH] = leaf_index.to_le_bits();\n\n    // `nodes` array to store computed node values at each level\n    // Size is MAX_DEPTH + 1 to store the initial leaf and results of MAX_DEPTH hashing/propagation steps.\n    let mut nodes: [Field; MAX_DEPTH + 1] = [0 as Field; MAX_DEPTH + 1];\n\n    // Initialize with the leaf value\n    nodes[0] = leaf;\n\n    // For each level up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        let current_node = nodes[i];\n        let sibling_node = siblings[i];\n\n        // `path_bits_field[i]` determines if `current_node` is a left (0) or right (1) child.\n        let path_direction_bit = path_bits_bool[i]; // 0 if current_node is left, 1 if current_node is right\n\n        // LeanIMT feature: if sibling_node is empty (0), propagate current_node.\n        // Otherwise, use the hash.\n        // `is_sibling_empty_selector` will be 1 if sibling_node is 0, and 0 otherwise.\n        let is_sibling_empty_selector = if sibling_node == 0 {\n            1 as Field\n        } else {\n            0 as Field\n        };\n\n        if is_sibling_empty_selector == 1 {\n            nodes[i + 1] = current_node;\n        } else {\n            let mut left_input: Field = 0 as Field;\n            let mut right_input: Field = 0 as Field;\n            if path_direction_bit == 0 {\n                left_input = current_node;\n                right_input = sibling_node;\n            } else {\n                left_input = sibling_node;\n                right_input = current_node;\n            }\n\n            // Hash the correctly ordered pair using BLAKE3\n            let hashed_pair = poseidon::poseidon2::Poseidon2::hash([left_input, right_input], 2);\n            nodes[i + 1] = hashed_pair;\n        }\n    }\n\n    // Output the final computed root\n    nodes[MAX_DEPTH]\n}\n\n#[test]\npub fn test_lean_imt_inclusion_proof() {\n    let leaf: Field = (4 as u8).into();\n    let leaf_index: Field = (3 as u8).into();\n    let siblings: [Field; 8] = [\n        3,\n        0x038682aa1cb5ae4e0a3f13da432a95c77c5c111f6f030faf9cad641ce1ed7383,\n        0x232400b3cca0da78d26295f345d21e9bf8949238bee02b285140ebf183119982,\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    let root = lean_imt_inclusion_proof(leaf, leaf_index, siblings);\n    assert(root == 0x05d7e5aaddb74c086c24617065e8c97dea94b86fdae0eab7b498249e0dfee2a8);\n}\n",
      path: "/mnt/c/codebases/xythum/dark-dex-research/dark-dex-v0/circuits/helpers/src/LeanIMTInclusionProof.nr",
    },
    "53": {
      source:
        "use poseidon;\n\n/**\n * @title CommitmentHasher function\n * @dev Function for computing commitment hashes, precommitments and nullifier hashes\n */\npub fn commitment_hasher(\n    nullifier: Field, // Nullifier of commitment\n    value: Field, // Value of commitment\n    label: Field,\n    secret: Field, // Secret of commitment\n) -> (Field) {\n    // println(nullifier);\n\n    let precommitment = poseidon::poseidon2::Poseidon2::hash([nullifier, secret], 2);\n    let commitment = poseidon::poseidon2::Poseidon2::hash([value, label, precommitment], 3);\n\n    // println([precommitment, commitment]);\n    (commitment)\n}\n\n#[test]\npub fn test_commitment_hasher() {\n    let nullifier: Field = (1 as u8).into();\n    let secret: Field = (2 as u8).into();\n    let value: Field = (1000000000000000000 as u64).into();\n    let label: Field = (0x4838b106fce9647bdf1e7877bf73ce8b0bad5f97).into();\n    let _commitment = commitment_hasher(nullifier, value, label, secret);\n    assert_eq(_commitment, 0x16e83a643e94248403eb0078a4b6996acf63857e47be823fdba2f0274aa66447)\n}\n",
      path: "/mnt/c/codebases/xythum/dark-dex-research/dark-dex-v0/circuits/helpers/src/commitment.nr",
    },
    "61": {
      source:
        "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      path: "/home/dimeb/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
    },
    "63": {
      source:
        "global MAX_TREE_DEPTH: u32 = 32;\n\nuse helpers::{commitment::commitment_hasher, LeanIMTInclusionProof::lean_imt_inclusion_proof};\n\nfn main(\n    // Public inputs\n    withdraw_value: pub Field,\n    merkle_root: pub Field,\n    existingNullifier: pub Field,\n    // Private inputs\n    leaf_index: Field,\n    label: Field,\n    existingValue: Field,\n    existingSecret: Field,\n    newNullifier: Field,\n    newSecret: Field,\n    siblings: [Field; MAX_TREE_DEPTH],\n) -> pub Field {\n    let existingCommitment =\n        commitment_hasher(existingNullifier, existingValue, label, existingSecret);\n\n    let computed_merkle_root = lean_imt_inclusion_proof(existingCommitment, leaf_index, siblings);\n\n    assert_eq(computed_merkle_root, merkle_root);\n\n    let newCommitment = commitment_hasher(\n        newNullifier,\n        existingValue - withdraw_value, // noir checks for underflows\n        label,\n        newSecret,\n    );\n    newCommitment\n}\n\n#[test]\npub fn test_main() {\n    let withdraw_value: Field = (500000000000000000).into();\n    let merkle_root: Field = 0x0de6f3accefd10fa9b4b051932b99164ed2a6c01b6e9b87c8780210106181625;\n    let leaf_index: Field = 17;\n    let existingNullifier: Field = 17;\n    let label: Field = 0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97;\n    let existingValue: Field = 1000000000000000000;\n    let existingSecret: Field = 34;\n    let newNullifier: Field = 601;\n    let newSecret: Field = 602;\n    let siblings: [Field; 32] = [\n        0x284732750a4c687dc1a5bdfd27a7d130838eb261b3efda082634f03f1381f8d0,\n        0x2f1992a8f3e396814096f43f8a39b43bab09f51c415928da0cca986759e30219,\n        0x10aa998dfa4f051bfefb09d4cce0df6ca7176c33d3217dabf8c7a8628dedf414,\n        0x0d2ce5ffec3b40e24e31f3cc77b4666855256bfc587b98620f0c9537e1fd7c98,\n        0x1afc3e11aef5abc81eacdb715050bda392f8949b779c5dfde8a17b9b9a1f225b,\n        0x2ba1a5a86b4ab6cb6fa65b4a9a467aa357215c3579a5440fb31f535578585d77,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n    ];\n    let _newCommitment = main(\n        withdraw_value,\n        merkle_root,\n        existingNullifier,\n        leaf_index,\n        label,\n        existingValue,\n        existingSecret,\n        newNullifier,\n        newSecret,\n        siblings,\n    );\n\n    assert(_newCommitment == 0x21adcd4c0b79b79f4564706cce1f55dad4f3211aa1d4b533ada3f4b1edbd41d6);\n}\n",
      path: "/mnt/c/codebases/xythum/dark-dex-research/dark-dex-v0/circuits/withdrawOrTransfer/src/main.nr",
    },
  },
  names: ["main"],
  brillig_names: ["directive_to_radix", "directive_invert"],
};
