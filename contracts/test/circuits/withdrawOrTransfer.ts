export const WithdrawTransferCircuit = {
  noir_version: "1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d",
  hash: "11182106105396493467",
  abi: {
    parameters: [
      { name: "withdraw_value", type: { kind: "field" }, visibility: "public" },
      { name: "merkle_root", type: { kind: "field" }, visibility: "public" },
      {
        name: "existingNullifier",
        type: { kind: "field" },
        visibility: "public",
      },
      { name: "leaf_index", type: { kind: "field" }, visibility: "private" },
      { name: "label", type: { kind: "field" }, visibility: "private" },
      { name: "existingValue", type: { kind: "field" }, visibility: "private" },
      {
        name: "existingSecret",
        type: { kind: "field" },
        visibility: "private",
      },
      { name: "newNullifier", type: { kind: "field" }, visibility: "private" },
      { name: "newSecret", type: { kind: "field" }, visibility: "private" },
      {
        name: "siblings",
        type: { kind: "array", length: 32, type: { kind: "field" } },
        visibility: "private",
      },
    ],
    return_type: { abi_type: { kind: "field" }, visibility: "public" },
    error_types: {
      "6485997221020871071": {
        error_kind: "string",
        string: "call to assert_max_bit_size",
      },
      "17843811134343075018": {
        error_kind: "string",
        string: "Stack too deep",
      },
    },
  },
  bytecode:
    "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",
  debug_symbols:
    "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",
  file_map: {
    "5": {
      source:
        "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      path: "std/cmp.nr",
    },
    "17": {
      source:
        "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      path: "std/field/bn254.nr",
    },
    "18": {
      source:
        'pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            "BIT_SIZE must be less than modulus_num_bits",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, "radix must be greater than 1");\n            static_assert(radix <= 256, "radix must be less than or equal to 256");\n            static_assert(radix & (radix - 1) == 0, "radix must be a power of 2");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, "radix must be greater than 1");\n            static_assert(radix <= 256, "radix must be less than or equal to 256");\n            static_assert(radix & (radix - 1) == 0, "radix must be a power of 2");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = "radix must be greater than 1")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f"radix must be greater than 1");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, "unexpected result");\n    //    }\n    //}\n\n    #[test(should_fail_with = "radix must be a power of 2")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f"radix must be a power of 2");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, "unexpected result");\n        }\n    }\n\n    #[test(should_fail_with = "radix must be less than or equal to 256")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f"radix must be less than or equal to 256")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, "unexpected result");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n',
      path: "std/field/mod.nr",
    },
    "22": {
      source:
        'pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated("wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated("wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated("wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = "custom message")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, "custom message");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n',
      path: "std/lib.nr",
    },
    "51": {
      source:
        "/**\n * @title LeanIMTInclusionProof function (Noir equivalent)\n * @dev Function for verifying inclusion proofs in a Lean Incremental Merkle Tree using BLAKE3 hashes.\n*/\npub fn lean_imt_inclusion_proof<let MAX_DEPTH: u32>(\n    leaf: Field,\n    leaf_index: Field, // The index of the leaf.\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    let path_bits_bool: [u1; MAX_DEPTH] = leaf_index.to_le_bits();\n\n    // `nodes` array to store computed node values at each level\n    // Size is MAX_DEPTH + 1 to store the initial leaf and results of MAX_DEPTH hashing/propagation steps.\n    let mut nodes: [Field; MAX_DEPTH + 1] = [0 as Field; MAX_DEPTH + 1];\n\n    // Initialize with the leaf value\n    nodes[0] = leaf;\n\n    // For each level up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        let current_node = nodes[i];\n        let sibling_node = siblings[i];\n\n        // `path_bits_field[i]` determines if `current_node` is a left (0) or right (1) child.\n        let path_direction_bit = path_bits_bool[i]; // 0 if current_node is left, 1 if current_node is right\n\n        // LeanIMT feature: if sibling_node is empty (0), propagate current_node.\n        // Otherwise, use the hash.\n        // `is_sibling_empty_selector` will be 1 if sibling_node is 0, and 0 otherwise.\n        let is_sibling_empty_selector = if sibling_node == 0 {\n            1 as Field\n        } else {\n            0 as Field\n        };\n\n        if is_sibling_empty_selector == 1 {\n            nodes[i + 1] = current_node;\n        } else {\n            let mut left_input: Field = 0 as Field;\n            let mut right_input: Field = 0 as Field;\n            if path_direction_bit == 0 {\n                left_input = current_node;\n                right_input = sibling_node;\n            } else {\n                left_input = sibling_node;\n                right_input = current_node;\n            }\n\n            // Hash the correctly ordered pair using BLAKE3\n            let hashed_pair = poseidon::poseidon2::Poseidon2::hash([left_input, right_input], 2);\n            nodes[i + 1] = hashed_pair;\n        }\n    }\n\n    // Output the final computed root\n    nodes[MAX_DEPTH]\n}\n\n#[test]\npub fn test_lean_imt_inclusion_proof() {\n    let leaf: Field = (4 as u8).into();\n    let leaf_index: Field = (3 as u8).into();\n    let siblings: [Field; 8] = [\n        3,\n        0x038682aa1cb5ae4e0a3f13da432a95c77c5c111f6f030faf9cad641ce1ed7383,\n        0x232400b3cca0da78d26295f345d21e9bf8949238bee02b285140ebf183119982,\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    let root = lean_imt_inclusion_proof(leaf, leaf_index, siblings);\n    assert(root == 0x05d7e5aaddb74c086c24617065e8c97dea94b86fdae0eab7b498249e0dfee2a8);\n}\n",
      path: "/mnt/c/codebases/xythum/dark-dex-research/dark-dex-v0/circuits/helpers/src/LeanIMTInclusionProof.nr",
    },
    "53": {
      source:
        "use poseidon;\n\n/**\n * @title CommitmentHasher function\n * @dev Function for computing commitment hashes, precommitments and nullifier hashes\n */\npub fn commitment_hasher(\n    nullifier: Field, // Nullifier of commitment\n    value: Field, // Value of commitment\n    label: Field,\n    secret: Field, // Secret of commitment\n) -> (Field) {\n    // println(nullifier);\n\n    let precommitment = poseidon::poseidon2::Poseidon2::hash([nullifier, secret], 2);\n    let commitment = poseidon::poseidon2::Poseidon2::hash([value, label, precommitment], 3);\n\n    // println([precommitment, commitment]);\n    (commitment)\n}\n\n#[test]\npub fn test_commitment_hasher() {\n    let nullifier: Field = (1 as u8).into();\n    let secret: Field = (2 as u8).into();\n    let value: Field = (1000000000000000000 as u64).into();\n    let label: Field = (0x4838b106fce9647bdf1e7877bf73ce8b0bad5f97).into();\n    let _commitment = commitment_hasher(nullifier, value, label, secret);\n    assert_eq(_commitment, 0x16e83a643e94248403eb0078a4b6996acf63857e47be823fdba2f0274aa66447)\n}\n",
      path: "/mnt/c/codebases/xythum/dark-dex-research/dark-dex-v0/circuits/helpers/src/commitment.nr",
    },
    "61": {
      source:
        "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      path: "/home/dimeb/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
    },
    "63": {
      source:
        "global MAX_TREE_DEPTH: u32 = 32;\n\nuse helpers::{commitment::commitment_hasher, LeanIMTInclusionProof::lean_imt_inclusion_proof};\n\nfn main(\n    // Public inputs\n    withdraw_value: pub Field,\n    merkle_root: pub Field,\n    existingNullifier: pub Field,\n    // Private inputs\n    leaf_index: Field,\n    label: Field,\n    existingValue: Field,\n    existingSecret: Field,\n    newNullifier: Field,\n    newSecret: Field,\n    siblings: [Field; MAX_TREE_DEPTH],\n) -> pub Field {\n    let existingCommitment =\n        commitment_hasher(existingNullifier, existingValue, label, existingSecret);\n\n    let computed_merkle_root = lean_imt_inclusion_proof(existingCommitment, leaf_index, siblings);\n    println(computed_merkle_root);\n    println(merkle_root);\n    assert(computed_merkle_root == merkle_root);\n\n    assert(withdraw_value.lt(existingValue) | withdraw_value.eq(existingValue));\n    let newCommitment = commitment_hasher(\n        newNullifier,\n        existingValue - withdraw_value, // noir checks for underflows\n        label,\n        newSecret,\n    );\n\n    newCommitment\n}\n\n#[test]\npub fn test_main() {\n    let withdraw_value: Field = (500000000000000000).into();\n    let merkle_root: Field = 0x0de6f3accefd10fa9b4b051932b99164ed2a6c01b6e9b87c8780210106181625;\n    let leaf_index: Field = 17;\n    let existingNullifier: Field = 17;\n    let label: Field = 0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97;\n    let existingValue: Field = 1000000000000000000;\n    let existingSecret: Field = 34;\n    let newNullifier: Field = 601;\n    let newSecret: Field = 602;\n    let siblings: [Field; 32] = [\n        0x284732750a4c687dc1a5bdfd27a7d130838eb261b3efda082634f03f1381f8d0,\n        0x2f1992a8f3e396814096f43f8a39b43bab09f51c415928da0cca986759e30219,\n        0x10aa998dfa4f051bfefb09d4cce0df6ca7176c33d3217dabf8c7a8628dedf414,\n        0x0d2ce5ffec3b40e24e31f3cc77b4666855256bfc587b98620f0c9537e1fd7c98,\n        0x1afc3e11aef5abc81eacdb715050bda392f8949b779c5dfde8a17b9b9a1f225b,\n        0x2ba1a5a86b4ab6cb6fa65b4a9a467aa357215c3579a5440fb31f535578585d77,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n    ];\n    let _newCommitment = main(\n        withdraw_value,\n        merkle_root,\n        existingNullifier,\n        leaf_index,\n        label,\n        existingValue,\n        existingSecret,\n        newNullifier,\n        newSecret,\n        siblings,\n    );\n\n    assert(_newCommitment == 0x21adcd4c0b79b79f4564706cce1f55dad4f3211aa1d4b533ada3f4b1edbd41d6);\n}\n\n#[test]\npub fn test_2() {\n    let existingNullifier: Field = 25546;\n    let existingSecret: Field = 684266;\n    let existingValue: Field = 2000000000000000000;\n    let label: Field = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    let leaf_index: Field = 7;\n    let merkle_root: Field = 0x296e1e1723de379d27580f37e0b326d569a3650ab9c42ef5012716f955c91cb1;\n    let newNullifier: Field = 744302;\n    let newSecret: Field = 275103;\n    let withdraw_value: Field = (6000000000000000000).into();\n    let siblings: [Field; 32] = [\n        0x058258da1abc94b10f0e7209fbb8a3ad1e9191c19dd9b0d5d1578740c889c89d,\n        0x24564c30952be56d77eae1d68490afa2c4117d54c1e4ea0068ad9ad1ec30db86,\n        0x24a6ead2b70f5bdcb928ae1d133bb435524cac77a693776e4e3c47c953f38020,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n    ];\n    let _newCommitment = main(\n        withdraw_value,\n        merkle_root,\n        existingNullifier,\n        leaf_index,\n        label,\n        existingValue,\n        existingSecret,\n        newNullifier,\n        newSecret,\n        siblings,\n    );\n\n    // assert(_newCommitment == 0x21adcd4c0b79b79f4564706cce1f55dad4f3211aa1d4b533ada3f4b1edbd41d6);\n}\n",
      path: "/mnt/c/codebases/xythum/dark-dex-research/dark-dex-v0/circuits/withdrawOrTransfer/src/main.nr",
    },
  },
  names: ["main"],
  brillig_names: [
    "print_unconstrained",
    "field_less_than",
    "decompose_hint",
    "lte_hint",
    "directive_to_radix",
    "directive_invert",
  ],
};
